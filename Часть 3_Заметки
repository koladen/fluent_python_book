Часть 3 Функции как объекты

У объекта - функции есть атрибут __defaults__, в котором хранится кортэж со значениями по умолчанию позиционных и
именованных параметров. Значения по умолчанию чисто именованных параметров хранятся в атрибуте __kwdefaults__. Сами же
имена параметров хранятся в атрибуте __code__, который содержит ссылку на объект code, со множеством собственных
атрибутов

Модуль operator
Позволяет упростить некоторые вызовы функций, вместо того, чтобы писать лямбда выражения
Например, operator.itemgetter - позволяет выбирать элементы из последовательностей
itemgetter(1) все равно что lambda fields: fields[1] создает функцию, коотроая получает коллекцию, и возвращает ее
элемент с индексом 1.
Поскольку itemgetter пользуется оператором [], он поддерживает все последовательности, включая словари, и вообще, любой
класс, где реализован __getitem__
attrgetter - создает функцию, для возвращения атрибутов объекта по имени
methodcaller - создает функцию, вызывающую метод по имени, для объекта переданного в качестве аргумента
Пример:
upcase = methodcaller('upper')
upcase('aaa') # 'AAA'

hip = methodcaller('replace', ' ', '-')
hip('a a a') # 'a-a-a'

ДЕКОРАТОРЫ

Декоратор - вызываемый объект, который принимает другую функцию в качестве аргумента. Декроратор может производить какие
либо действия с этой функцией, и возвращает либо ее саму, либо другую, заменяющую ее функцию  или вызываемый объект.
Декораторы функций выполняются СРАЗУ ПОСЛЕ ИМПОРТА МОДУЛЯ!, но сами декорированные функции выполняются только в
результате прямого вызова.

Пример декоратора, для регитсрации неких функций в списке:
promos = []

def reg_promos(func):
    promos.append(func)
    return func

@reg_promos
def promo1():
    pass

@reg_promos
def promo2():
    pass

ЗАМЫКАНИЯ

Замыкание - функция, которая запоминает привязки свободных переменных, существовавщие на момент определения функции, так
что их можно использовать впоследствии при вызове функции, когда область видимости, в которой она была определена уже
не существует.

Python хранит имена локальных и свободных переменных в атрибуте __code__, который представляет собой откомпилированное
тело функции
Привязка переменной series хранится в атрибуте __closure__ возвращенной функции avg. Каждому элементу avg.__closure__
соответствует имя в avg.__code__.co_freevars
Эти элементы называются ячейками, и у каждой ячейки есть атрибут cell_contents, где можно найти значение

#Пример 7.9

def make_averager():
    series = [] # это та самая свободная переменная
    def average(n):
        series.append(n)
        total = sum(series)
        return total/len(series)
    return average

avg = make_averager()
print(avg(10)) #10
print(avg(11)) #10.5
print(avg.__code__.co_freevars) #('series',)
print(avg.__closure__) #(<cell at 0x0000000002119798: list object at 0x00000000003C5208>,)
print(avg.__closure__[0].cell_contents) #[10, 11]

Объявление nonlocal - позволяет назначать переменные свободными, чтобы замыкание сохраняло их значение.

#Пример 7.14

def make_averager():
    total = 0
    count = 0
    def average(n):
        nonlocal count, total #Тут мы объявляем эти переменные свободными, т.к. если эот не сделать, они станут
        # локальными и код выдаст ошибку. А в этом случае их значение будет сохраняться так же, как в предыдущем примере
        count += 1
        total += n
        return total/count
    return average

avg = make_averager()
print(avg(10)) #10
print(avg(11)) #10.5


Декоратор functools.lru_cache() - применяется для кэширования результатов вызова функции. Если аргумент функции
тот же, результат вернется из кэша

Декоратор singledispatchmethod. Позволяет диспетчеризировать функцию, в зависимости от типа аргумента

#Пример с singledispatch
from functools import singledispatchmethod
class Negator:
    @singledispatchmethod
    def neg(self, arg): # Функция назначаемая диспетчером
        raise NotImplementedError("Cannot negate a")

    @neg.register
    def _(self, arg: int): #Определенное поведение, если тип - int. Причем имя функции вообще не важно
        return -arg

    @neg.register
    def _(self, arg: bool): #Аналогично, если тип - bool
        return not arg

a = Negator()
print(a.neg(True)) #False
print(a.neg(1)) #-1

ДОПОЛНИТЕЛЬНАЯ ЛИТЕРАТУРА:
https://pypi.org/project/decorator/
https://github.com/micheles/decorator/blob/master/docs/documentation.md