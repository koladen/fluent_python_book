Часть 2: Структуры данных

Контейнерные последовательности (в своем составе могут хранить объекты различных типов):
list, tuple, collections.deque
Хранятся ССЫЛКИ на объекты любого типа

Плоские последовательности (могут хранить элементы только одного тпа):
str, bytes, bytearray, memoryview, array.array
Хранятся САМИ ЗНАЧЕНИЯ. Поэтому плоские последовательности компактнее, но могут содержать только примитивные типы

Изменяемые последовательности:
list, bytearray, array.array, collections.deque, memoryview

Неизменяемые последовательности:
str, tuple, bytes


Экземпляры класса построенного с помощью namedtuple потребляют столько же памяти, сколько и кортэжи, потому что имена
полей хранятся в определении класса, при этом они занимают меньше памяти, чем обычные объекты, т.к. атрибуты не
хранятся в атрибуте __dict__ на уровне экземпляра
_fields - кортэж содержащий имена полей данного namedtuple
_make() - позволяет создать экземпляр namedtuple из итерируемого объекта. Конструктор
НаименованиеТапла(*ИтерируемыйОбъект)  - делает то же самое
_asdict() - возвращает объект collections.OrderedDict, построенный по namedtuple. Можно использовать для форматирования
данных при выводе.

Срезы

Для вычисления среза seq[start:stop:step], Python использует операцию seq.__getitem__(slice(start, stop, step))

Срезы можно именовать:
DESCRIPTION = slice(6, 40)
UNIT_PRICE = slice(40, 52)
print(item[DESCRIPTION], item[UNIT_PRICE])

l[2:5] = [20, 30] - все нормально, ошибки нет
l[2:5] = 100 - ошибка. Если в левой части стоит срез, то в правой должен быть итерируемый объект, даже если он один,
т.е. правильно будет так l[2:5] = [100]

Пример построения списка списков:
1) Верный
board = [['_']*3 for _ in range(3)]

2) Неверный
wrong_board = [['_']*3]*3
В эотм случае внешний список содержит 3 ссылки на один и тот же внутренний список!

Средства для работы с упорядоченными последовательностями в модуле bisect:
Функция bisect(haystack, needle) - производит двоичный поиск иголки(needle) в стоге сена(haystack). Стог сена должен
быть предварительно отсортирован. Результатом является позиция в которую нужно вставить needle, чтобы последовательность
осталась отсортированной
Функция insort(seq, item) вставляет итем в последовательность сек таким образом, чтобы последовательность оставалась в
порядке возрастания

Тип list гибкий и удобный, но подходит не всегда. Если нужно хранить, например, большое число чисел с плавающей точкой,
то более эффективным выбором будет тип array, поскольку числа в нем хранятся в специальном, более эффективном формате.
Если часто добавляем и удаляем элементы с обоих концов списка, то лучший выбор - deque


СЛОВАРИ И МНОЖЕСТВА

Пространства имен модулей, атрибуты классов и экземпляров, именованные аргументы функций - это все словари.
Встроенные функции хранятся в словаре __builtins__.__dict__
Словари и множества организованы в виде хэш таблиц
Соответственно, ключи словарей должны быть хэшируемымми. Что это означает: объект хэшируем, если имеет хэш значение,
которое не изменяется на протяжении всей его жизни (у него должен быть метод __hash__()) и допускает сравнение с
другими объектами (у него должен быть метод __eq__()). Если в результате сравнения объектов оказывается, что они
равны, то и их хэши должны быть равны.
Все атомарные неизменяемые типы (str, bytes, числовые типы) - хэшируемы. Frozenset - хэшируемый. Tuple хэшируемый,
только если все его элементы хэшируемы.
Любой пользовательский элемент хэшируем, потому что его хэш значение равно id() и никакие 2 элемента этого типа не равны
Если объект реализует метод __eq__, учитывающий внутреннее состояние, то он будет хэшируемый, только если все атрибуты
неизменяемы.
Метод __missing__. Вызывается, ТОЛЬКО когда __getitem__ не нашел значение по ключу