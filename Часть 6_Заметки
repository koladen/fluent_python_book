Метапрограммирование и метаклассы

Быстрый способ создать несколько атрибутов экземпляра

class Record:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

В словаре __dict__ хранятся все атрибуты класса и их значения

Итак, чтобы получить значение атрибута attrname экземпляра a в python:
Если определён метод a.__class__.__getattribute__(), то вызывается он и возвращается полученное значение.
Если attrname это специальный (определённый python-ом) атрибут, такой как __class__ или __doc__, возвращается его
значение.
Проверяется a.__class__.__dict__ на наличие записи с attrname. Если она существует и значением является дескриптор
данных, возвращается результат вызова метода __get__() дескриптора. Также проверяются все базовые классы.
Если в a.__dict__ существует запись с именем attrname, возвращается значение этой записи. Если a — это класс, то атрибут
ищется и среди его базовых классов и, если там или в __dict__ a дескриптор данных — возвращается результат __get__()
дескриптора.
Проверяется a.__class__.__dict__, если в нём существует запись с attrname и это “дескриптор не данных”, возвращается
результат __get__() дескриптора, если запись существует и там не дескриптор, возвращается значение записи. Также
обыскиваются базовые классы.
Если существует метод a.__class__.__getattr__(), он вызывается и возвращается его результат. Если такого метода нет —
выкидывается AttributeError.

Чтобы установить значение value атрибута attrname экземпляра a:
Если существует метод a.__class__.__setattr__(), он вызывается.
Проверяется a.__class__.__dict__, если в нём есть запись с attrname и это дескриптор данных — вызывается метод __set__()
 дескриптора. Также проверяются базовые классы.
В a.__dict__ добавляется запись value с ключом attrname.

Встроенные функции для работы с атрибутами:

1) dir([object]) - перечисляет большую часть атрибутов объекта. Если аргумент object не задан, выводит имена в текущей
области видимости
2) getattr(object, name[, default]) - получает артибут, имеющий имя name объекта object. В результате может быть найден
атрибут определенный в классе или суперклассе объекта. Если такого атрибута нет, возбуждает исключение AttributeError,
либо возвращает значение default
3) hasattr(object, name) - возвращает True, если атрибут с указанным именем существует в объекте или может быть найден с
его помощью (например в результате наследования)
4) setattr(object, name, value) - устанавливает значение value атрибута name объекта. В результате может быть создан
новый атрибут, или возвращен существующий
5) vars([object]) - возвращает атрибут __dict__ объекта object


Дескрипторы

Класс в котором реализован хотя бы один из методов __get__, __set__ или __delete__ - называется дескриптором
Для использования дескриптора, мы объявляем его экземпляром атрибут какого-то другого класса

Пример:
class Quantity:  # <1>

    def __init__(self, storage_name):
        self.storage_name = storage_name  # Здесь хранится значение управляемго экземпляра

    def __set__(self, instance, value):  # Метод вызывается при любой попытке присвоить значение управляемому атрибуту
                                         # instance в данном случае это управляемый экземпляр
        if value > 0:
            instance.__dict__[self.storage_name] = value  # Тут мы должны работать с __dict__ управляемого экземпляра
                                                          # попытка вызвать setattr приведет к повторному вызову __set__
                                                          # и зацикливанию
        else:
            raise ValueError('value must be > 0')


class LineItem:
    weight = Quantity('weight')  # Первый экземпляр дескриптора связывается с атрибутом weight
    price = Quantity('price')  # <6>

    def __init__(self, description, weight, price):  # <7>
        self.description = description
        self.weight = weight
        self.price = price

    def subtotal(self):
        return self.weight * self.price